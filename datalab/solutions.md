### **1. bitAnd**

利用De Morgan定律，有x&y=~(~x)|(~y)

### **2. getByte**
取从左边起第n个字节(n=0,1,2,3)，只需将x右移8*n位，然后用0xff进行掩码即可。8*n即是n<<3.

### **3. logicalShift**
题目要求进行逻辑右移，而在C语言中补码表示默认情况下是算术右移，可以首先将x进行算术右移，然后进行掩码操作将左边的符号位置0即可。记x的符号位$x_{31}$移到了$x_y$位，其中$y=31-n=32+$(~n)(题目要求不能使用减法).然后取1...1(y+1个1)进行掩码。1...1(y+1个1)可以利用下面的代码获得:
```c
    (1<<y)+(~0)+(1<<y);
```
注意上述代码不能写成如下形式:
```c
    (1<<y)+(1<<y)+(~0);
```
当$y=31$，即$n=0$时，$1<<y=1<<31$,$(1<<y)+(1<<y)$会造成下溢，结果为0，加上~0后即为0xffffffff，结果仍然是算术右移。
### **4. bitCount**
这题应该是本次lab最难的题，完全没思路用位运算解决，参考了网上大佬的解答。

我们可以先来一个简单的例子:x为两位二进制数，如何得到x中1的个数？显然直接
```c
    (x&1)+((x>>1)&1);
```
那么如何算出32位二进制数x中1的个数呢？根据上述例子，我们可以先进行如下操作:
```c
    y=(x&0x55555555)+((x>>1)&0x55555555);
```
因为0x55555555的二进制表示间隔为1，x%0x55555555将偶数位保存下来，(x>>1)&0x55555555将奇数位保存下来，然后进行相加，则x的每两位中1的个数即是y中相应的每两位的十进制值。
然后再对y进行如下操作:
```c
    z=(y&0x33333333)+((y>>2)&0x33333333);
```
因为0x33333333的二进制表示间隔为2，y&0x33333333每隔两位将两位保存下来，（y>>2)&0x33333333将剩下的保存下来(也是每隔两位)，然后进行相加，则x的每四位中1的个数即是z中相应的每四位的十进制值。
……
以此类推
接下来进行掩码的数是0x0f0f0f0f(每隔四位)、0x00ff00ff(每隔八位)、0x0000ffff(每隔十六位），按照上面的方面，分别右移4位、8位、16位，然后进行相加，最后的值即是x中1的个数。



### **5. bang**

实现!x操作，只需注意到当$x≠0$，x和-x中必有一个符号位为1即可。

### **6. tmin**
32位的补码表示最小正整数为0x80000000，用1<<31即可得到

### **7. fitsBits**
判断x能否表示成n位补码。
分情况讨论，x是非负数时,将x右移$n-1$位即可得到0；x是负数时，将-x右移$n-1$位即可得到0。

### **8. divpwr2**
补码表示除以$2^n$，正数是向下取整，负数是向上取整，负数需要加上bias，书上的代码如下:
```c
    (x<0?x+(1<<n)-1:x)>>n;
```

### **9. negate**

利用-x=~x+1即可。

### **10. isPositive**
判断x是否是正数，先判断x的符号位为0，再排除0的情况即可。

### **11. isLessOrEqual**
判断x是否小于等于y。
当x的符号位为1、y的符号位为0时，显然x小于等于y。否则直接相减判断，x≤y，x-y=x+(~y)+1≤0，x+(~y)＜0，即可判断。

### **12. ilog2**
这题即要求x的二进制表示中最高位的1的位置。
利用分治法的思想，先判断左16位，左16位没有1，则判断右16位，否则判断左8位，以此类推。
考虑到答案是[0,31]中的某个数，可以用二进制编码为$\overline{abcde}$，即ilog2(x)=$16*a+8*b+4*c+2*d+e$，其中abcde均是0或1.
下面以此求abcde
利用$$
        !!x =
        \begin{cases}
        0,  & x=0 \\
        1, & x≠0
        \end{cases}
$$可判断x是否是0
先看左16位!!(x>>16)，若为0，则a=0；否则a=1，左移4位得到16*a.然后根据左16位的情况，左16位不为0，需要右移24位(看左8位)，否则右移8位(看$x_{15}$到$x_8$），即右移8+ans位，然后利用!!(x>>(8+ans))求b，再左移3位求8*b。。以此类推，即可求出ilog2(x)=$16*a+8*b+4*c+2*d+e$.


### **13. float_neg**
这题要求将参数uf和结果都理解为单精度浮点数的二进制表示.如果是nan，直接返回nan即可。否则将符号取反即可，注意到单精度浮点数的二进制表示第一位即是符号位，与0x80000000进行或运算即可。

### **14.  float_i2f**
这题要求把一个int转化成float表示，先判断正负，然后取绝对值。由于x为整数，故一定为normalized number，可直接通过 x 大小获得其浮点形式的指数位，再将 x 左移获得 frac 位。需要注意舍入问题(若frac为23+位，需要进行舍入)，因为浮点数默认的是向偶数舍入，要根据frac进行判断。

### **15. float_twice**
这题要求将参数uf和结果都理解为单精度浮点数的二进制表示，其中结果为参数uf表示的单精度浮点数的值的二倍的单精度浮点数的二进制表示，可能有点乱，其实就是将uf表示的值的二倍用单精度浮点数表示。
考虑到浮点数有四种表示，其中infinity和nan直接返回即可。
若uf为normalized number，指数位加1即可，同时要考虑加1后指数为可能变成0xff(infinity)，此时需要将尾数位变成0。
若uf为denormalized number，此时指数位全为0，乘以2，直接将尾数位左移一位，同时保持符号位不变即可。
